# CLAUDE.md

This file provides guidance to [Claude Code](https://claude.ai/code) when working with code in this repository.

## Project Overview

AuthGate is an OAuth 2.0 Device Authorization Grant (RFC 8628) server built with Go and Gin. It enables CLI tools to authenticate users without embedding client secrets.

## Common Commands

```bash
# Build
make build              # Build to bin/authgate with version info in LDFLAGS

# Run
./bin/authgate -v       # Show version information
./bin/authgate -h       # Show help
./bin/authgate server   # Start the OAuth server

# Test & Lint
make test               # Run tests with coverage report (outputs coverage.txt)
make lint               # Run golangci-lint (auto-installs if missing)
make fmt                # Format code with golangci-lint fmt

# Cross-compile (outputs to release/<os>/<arch>/)
make build_linux_amd64  # CGO_ENABLED=0 for static binary
make build_linux_arm64  # CGO_ENABLED=0 for static binary

# Clean
make clean              # Remove bin/, release/, coverage.txt

# Docker
docker build -f docker/Dockerfile -t authgate .
```

## Architecture

**Device Authorization Flow**:

1. CLI calls `POST /oauth/device/code` with client_id → receives device_code + user_code + verification_uri
2. User visits verification_uri (`/device`) in browser, must login first if not authenticated
3. User submits user_code via `POST /device/verify` → device code marked as authorized
4. CLI polls `POST /oauth/token` with device_code every 5s → receives JWT when authorized

**Layers** (dependency injection pattern):

- `main.go` - Wires up store → auth providers → services → handlers, configures Gin router with session middleware
- `config/` - Loads .env via godotenv, provides Config struct with defaults
- `store/` - GORM-based data access layer, supports SQLite and PostgreSQL via driver factory pattern
  - `driver.go` - Database driver factory using map-based pattern (no if-else)
  - `sqlite.go` - Store implementation and database operations (driver-agnostic)
- `auth/` - Authentication providers (LocalAuthProvider, HTTPAPIAuthProvider) with pluggable design
- `services/` - Business logic (UserService, DeviceService, TokenService), depends on Store and Auth providers
- `handlers/` - HTTP handlers (AuthHandler, DeviceHandler, TokenHandler), depends on Services
- `models/` - GORM models (User, OAuthClient, DeviceCode, AccessToken)
- `middleware/` - Gin middleware (auth.go: RequireAuth checks session for user_id)

**Authentication Architecture**:

- **Pluggable Providers**: Supports local (database) and external HTTP API authentication
- **Hybrid Mode**: Each user authenticates based on their `auth_source` field
- **Auth Mode**: Configured via `AUTH_MODE` env var (`local` or `http_api`), defaults to `local`
- **User Sync**: External auth automatically creates/updates users in local database
- **No Interfaces**: Direct struct dependency injection (project convention)
- **Authentication Flow**:
  1. UserService looks up user by username
  2. If user exists: route to provider based on user's `auth_source` field
     - `auth_source=local`: LocalAuthProvider (bcrypt against database)
     - `auth_source=http_api`: HTTPAPIAuthProvider (call external API)
  3. If user doesn't exist and `AUTH_MODE=http_api`: try external auth and create user
  4. Default admin user always uses local authentication (failsafe)
- **User Fields**: ExternalID, AuthSource, Email, FullName added for external auth support
- **Key Benefit**: Admin can always login locally even if external service is down

**Key Implementation Details**:

- Device codes expire after 30min (configurable via Config.DeviceCodeExpiration)
- User codes are 8-char uppercase alphanumeric (generated by generateUserCode in services/device.go)
- User codes normalized: uppercase + dashes removed before lookup
- JWTs signed with HMAC-SHA256, expire after 1 hour (Config.JWTExpiration)
- Sessions stored in encrypted cookies (gin-contrib/sessions), 7-day expiry
- Polling interval is 5 seconds (Config.PollingInterval)
- Templates and static files embedded via go:embed in main.go

**Key Endpoints**:

- `GET /health` - Health check with database connection test
- `POST /oauth/device/code` - CLI requests device+user codes (accepts form or JSON)
- `POST /oauth/token` - CLI polls for JWT (grant_type=urn:ietf:params:oauth:grant-type:device_code)
- `GET /oauth/tokeninfo` - Verify JWT validity
- `GET /device` - User authorization page (protected, requires login)
- `POST /device/verify` - User submits code to authorize device (protected)
- `GET|POST /login` - User authentication
- `GET /logout` - Clear session

**Error Handling**: Services return typed errors (ErrInvalidClient, ErrDeviceCodeNotFound, etc.), handlers convert to RFC 8628 OAuth error responses

## Environment Variables

| Variable                      | Default                 | Description                                             |
| ----------------------------- | ----------------------- | ------------------------------------------------------- |
| SERVER_ADDR                   | :8080                   | Listen address                                          |
| BASE_URL                      | `http://localhost:8080` | Public URL for verification_uri                         |
| JWT_SECRET                    | (default)               | JWT signing key                                         |
| SESSION_SECRET                | (default)               | Cookie encryption key                                   |
| DATABASE_DRIVER               | sqlite                  | Database driver ("sqlite" or "postgres")                |
| DATABASE_DSN                  | oauth.db                | Connection string (path for SQLite, DSN for PostgreSQL) |
| **AUTH_MODE**                 | local                   | Authentication mode: `local` or `http_api`              |
| HTTP_API_URL                  | (none)                  | External auth API endpoint (required for http_api)      |
| HTTP_API_TIMEOUT              | 10s                     | HTTP API request timeout                                |
| HTTP_API_INSECURE_SKIP_VERIFY | false                   | Skip TLS verification (dev/testing only)                |

## Default Test Data

Seeded automatically on first run (store/sqlite.go:seedData):

- User: `admin` / `<random_password>` (16-character random password, logged at startup, bcrypt hashed)
- Client: `AuthGate CLI` (client_id is auto-generated UUID, logged at startup)

## Example CLI Client

`_example/authgate-cli/` contains a demo CLI that demonstrates the device flow:

```bash
cd _example/authgate-cli
cp .env.example .env      # Add CLIENT_ID from server logs
go run main.go
```

## External Authentication Configuration

### HTTP API Authentication

To use external HTTP API for authentication, configure these environment variables:

```bash
AUTH_MODE=http_api
HTTP_API_URL=https://your-auth-api.com/verify
HTTP_API_TIMEOUT=10s
HTTP_API_INSECURE_SKIP_VERIFY=false
```

**Expected API Contract:**

Request (POST to HTTP_API_URL):

```json
{
  "username": "john",
  "password": "secret123"
}
```

Response:

```json
{
  "success": true,
  "user_id": "external-user-id",
  "email": "john@example.com",
  "full_name": "John Doe"
}
```

**Response Requirements:**

- `success` (required): Boolean indicating authentication result
- `user_id` (required when success=true): Non-empty string uniquely identifying the user in external system
- `email` (optional): User's email address
- `full_name` (optional): User's display name
- `message` (optional): Error message when success=false or HTTP status is non-2xx

**Behavior:**

- First login auto-creates user in local database with `auth_source="http_api"`
- Subsequent logins update user info (email, full_name)
- Users get default "user" role (admins must be promoted manually)
- External users stored with `auth_source="http_api"` and `external_id` set
- Each user authenticates based on their own `auth_source` field (hybrid mode)
- Default admin user (`auth_source="local"`) can always login even if external API is down
- Missing or empty `user_id` when `success=true` will cause authentication to fail
- **Username conflicts**: If external username matches existing user, login fails with error
  - User sees: "Username conflict with existing user. Please contact administrator."
  - Administrator must either: (1) rename existing user, (2) update external API username, or (3) manually merge accounts

### Local Authentication (Default)

No additional configuration needed. Users authenticate against local SQLite database:

```bash
AUTH_MODE=local  # or omit AUTH_MODE entirely
```

### Hybrid Mode Advantages

The system supports **per-user authentication routing** based on the `auth_source` field:

- **Failsafe Admin Access**: Default admin user always uses local auth, providing emergency access
- **Mixed User Base**: Can have both local and external users in the same system
- **Zero Downtime Migration**: Gradually migrate users from local to external auth
- **Service Independence**: External service outage doesn't lock out local users

**Example Scenario:**

1. Server starts with `AUTH_MODE=http_api`
2. Default admin user created with `auth_source=local` (can always login)
3. External users authenticate via HTTP API, created with `auth_source=http_api`
4. Each user authenticates via their designated provider
5. If external API fails, admin can still login to manage the system

## Coding Conventions

- Use `http.StatusOK`, `http.StatusBadRequest`, etc. instead of numeric status codes
- Services return typed errors, handlers convert to appropriate HTTP responses
- GORM models use `gorm.Model` for CreatedAt/UpdatedAt/DeletedAt
- Handlers accept both form-encoded and JSON request bodies where applicable
- All static assets and templates are embedded via `//go:embed` for single-binary deployment
- Database connection health check available via `store.Health()` method
- **IMPORTANT**: Before committing changes:
  1. **Write tests**: All new features and bug fixes MUST include corresponding unit tests
  2. **Format code**: Run `make fmt` to automatically fix code formatting issues and ensure consistency
  3. **Pass linting**: Run `make lint` to verify all code passes linting without errors
